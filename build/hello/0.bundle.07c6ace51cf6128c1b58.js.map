{"version":3,"sources":["webpack:///./src/crate/pkg/index.js"],"names":["cachegetUint8Memory","getUint8Memory","buffer","Uint8Array","WASM_VECTOR_LEN","cachegetInt32Memory","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","getStringFromWasm","ptr","len","decode","subarray","QrDetector","obj","Object","create","prototype","this","arg0","width","height","ret","__wrap","ptr0","arg","length","set","passArray8ToWasm","len0","memi32","Int32Array","v0","retptr","slice","__wbindgen_throw","arg1","Error"],"mappings":"uFAAA,8GAEA,IAAIA,EAAsB,KAC1B,SAASC,IAIL,OAH4B,OAAxBD,GAAgCA,EAAoBE,SAAW,IAAYA,SAC3EF,EAAsB,IAAIG,WAAW,IAAYD,SAE9CF,EAGX,IAAII,EAAkB,EAStB,IAAIC,EAAsB,KAQ1B,IAAIC,EAAoB,IAAIC,YAAY,QAAS,CAAEC,WAAW,EAAMC,OAAO,IAI3E,SAASC,EAAkBC,EAAKC,GAC5B,OAAON,EAAkBO,OAAOZ,IAAiBa,SAASH,EAAKA,EAAMC,IAHzEN,EAAkBO,SAOX,MAAME,EAET,cAAcJ,GACV,MAAMK,EAAMC,OAAOC,OAAOH,EAAWI,WAGrC,OAFAH,EAAIL,IAAMA,EAEHK,EAGX,OACI,MAAML,EAAMS,KAAKT,IACjBS,KAAKT,IAAM,EAEX,IAA2BA,GAK/B,YAEI,OADY,IAAgCS,KAAKT,OAClC,EAKnB,UAAUU,GACN,IAAgCD,KAAKT,IAAKU,GAK9C,aAEI,OADY,IAAiCD,KAAKT,OACnC,EAKnB,WAAWU,GACP,IAAiCD,KAAKT,IAAKU,GAO/C,WAAWC,EAAOC,GACd,MAAMC,EAAM,IAAoBF,EAAOC,GACvC,OAAOR,EAAWU,OAAOD,GAO7B,OAAOtB,GACH,MACMwB,EAjFd,SAA0BC,GACtB,MAAMhB,EAAM,IAAoC,EAAbgB,EAAIC,QAGvC,OAFA3B,IAAiB4B,IAAIF,EAAKhB,EAAM,GAChCP,EAAkBuB,EAAIC,OACfjB,EA6EUmB,CAAiB5B,GACxB6B,EAAO3B,EACb,IACgB,IAJD,EAIgCgB,KAAKT,IAAKe,EAAMK,GAA3D,MACMC,GA5Ec,OAAxB3B,GAAgCA,EAAoBH,SAAW,IAAYA,SAC3EG,EAAsB,IAAI4B,WAAW,IAAY/B,SAE9CG,GA0EO6B,EAAKxB,EAAkBsB,EAAOG,GAAiBH,EAAOG,IAAiBC,QAE7E,OADA,IAAqBJ,EAAOG,GAA0C,EAAzBH,EAAOG,IAC7CD,EACT,QACEhC,EAAO2B,IAAI5B,IAAiBa,SAASY,EAAO,EAAGA,EAAO,EAAIK,IAC1D,IAAqBL,EAAa,EAAPK,KAKhC,MAAMM,EAAmB,SAAShB,EAAMiB,GAC3C,MAAM,IAAIC,MAAM7B,EAAkBW,EAAMiB,M","file":"0.bundle.07c6ace51cf6128c1b58.js","sourcesContent":["import * as wasm from './index_bg.wasm';\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm(arg) {\n    const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n    getUint8Memory().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory = null;\nfunction getInt32Memory() {\n    if (cachegetInt32Memory === null || cachegetInt32Memory.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n}\n/**\n*/\nexport class QrDetector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(QrDetector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_qrdetector_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get width() {\n        const ret = wasm.__wbg_get_qrdetector_width(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set width(arg0) {\n        wasm.__wbg_set_qrdetector_width(this.ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get height() {\n        const ret = wasm.__wbg_get_qrdetector_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set height(arg0) {\n        wasm.__wbg_set_qrdetector_height(this.ptr, arg0);\n    }\n    /**\n    * @param {number} width\n    * @param {number} height\n    * @returns {QrDetector}\n    */\n    static new(width, height) {\n        const ret = wasm.qrdetector_new(width, height);\n        return QrDetector.__wrap(ret);\n    }\n    /**\n    * detect qrcode\n    * @param {Uint8Array} buffer\n    * @returns {string}\n    */\n    detect(buffer) {\n        const retptr = 8;\n        const ptr0 = passArray8ToWasm(buffer);\n        const len0 = WASM_VECTOR_LEN;\n        try {\n            const ret = wasm.qrdetector_detect(retptr, this.ptr, ptr0, len0);\n            const memi32 = getInt32Memory();\n            const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();\n            wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);\n            return v0;\n        } finally {\n            buffer.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));\n            wasm.__wbindgen_free(ptr0, len0 * 1);\n        }\n    }\n}\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm(arg0, arg1));\n};\n\n"],"sourceRoot":""}